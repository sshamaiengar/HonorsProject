<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
		<title>THE ART OF CODE</title>

		<!-- Bootstrap -->

		<link href="../node_modules/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
<!-- 		<link href="../node_modules/flat-ui/css/flat-ui.css" rel = "stylesheet">
-->		<link href="../css/sidebar.css" rel="stylesheet">
		
		
<link href="../css/gamedev.css" rel="stylesheet">
<link href="../css/ocean.dark.css" rel="stylesheet">
<script type='text/javascript' src='../js/phaser.min.js'></script>

		<!-- <link href="../css/sidebar.css" rel="stylesheet">
		<link href="../css/page-content.css" rel="stylesheet"> -->

		<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
		<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
		<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		<![endif]-->
		<script src="../node_modules/brython/www/src/brython.js"></script>

		<!-- Ace Editor -->
		<script src="../node_modules/ace-editor-builds/src/ace.js"></script>

		<!-- CodeMirror -->
		<script src="../node_modules/codemirror/lib/codemirror.js"></script>
		<script src="../node_modules/codemirror/addon/edit/closebrackets.js"></script>
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src = "../node_modules/jquery/dist/jquery.min.js" type = "text/javascript"></script>

		<script src="../node_modules/jq-console/jqconsole.min.js"></script>

		<link rel="stylesheet" href="../node_modules/codemirror/lib/codemirror.css">
		<link rel="stylesheet" href="../node_modules/codemirror/theme/rubyblue.css">
		<link rel="stylesheet" href="../node_modules/codemirror/theme/mdn-like.css">
		<script src="../node_modules/codemirror/mode/python/python.js"></script>
		<script src="../node_modules/codemirror/mode/htmlmixed/htmlmixed.js"></script>
		<script src="../node_modules/codemirror/mode/css/css.js"></script>
		<script src="../node_modules/codemirror/mode/clike/clike.js"></script>
	</head>
	<body>
		<div id="wrapper">
			<div class="overlay"></div>
			<!-- Sidebar -->
<nav class="navbar navbar-inverse navbar-fixed-top" id="sidebar-wrapper" role="navigation">
	<ul class="nav sidebar-nav">
		<li class="sidebar-brand">
			<a href="../index.html"><strong>
				The Art <br>of Code
				</strong>
			</a>
		</li>
		<li>
			<a href="../index.html">Home</a>
		</li>
		<li class="dropdown">
			<a href="#" class="dropdown-toggle" data-toggle="dropdown">
				Problem-Solving
				<span class="caret"></span>
			</a>
			<ul class="dropdown-menu" role="menu">
				<li><a href="../probsolve/intro.html">Introduction</a></li>
				<li><a href="../probsolve/helloWorld.html">Hello, World!</a></li>
				<li><a href="../probsolve/variables.html">Variables and Types</a></li>
				<li><a href="../probsolve/math.html">Basic Math</a></li>
				<li><a href="../probsolve/controlFlow.html">Control Flow</a></li>
				<li><a href="../probsolve/loops.html">Loops</a></li>
				<li><a href="../probsolve/dataStructures.html">Data Structures</a></li>
				<li><a href="../probsolve/functions.html">Functions</a></li>
				<li><a href="../probsolve/advancedTopics.html">Advanced Topics</a></li>
			</ul>
		</li>
		<li class="dropdown">
			<a href="#" class="dropdown-toggle" data-toggle="dropdown">
				Web Development
				<span class="caret"></span>
			</a>
			<ul class="dropdown-menu" role="menu">
				<li><a href="../webdev/intro.html">Introduction</a></li>
				<li><a href="../webdev/helloWorld.html">Hello, World!</a></li>
				<li><a href="../webdev/basicElements.html">Basic Elements</a></li>
				<li><a href="../webdev/otherElements.html">More Elements</a></li>
				<li><a href="../webdev/attributes.html">HTML Attributes</a></li>
				<li><a href="../webdev/style.html">Style</a></li>
				<li><a href="../webdev/textStyle.html">Text Styles</a></li>
				<li><a href="../webdev/blockStyle.html">Block Element Styles</a></li>
				<li><a href="../webdev/layout.html">Layout and Position</a></li>
				<li><a href="../webdev/advancedTopics.html">Advanced Topics</a></li>
			</ul>
		</li>
		
		<li class="dropdown">
			<a href="#" class="dropdown-toggle" data-toggle="dropdown">
				Game Development
				<span class="caret"></span>
			</a>
			<ul class="dropdown-menu" role="menu">
				<li><a href="../gamedev/intro.html">Introduction</a></li>
				<li><a href="../gamedev/helloWorld.html">Hello, World!</a></li>
				<li><a href="../gamedev/variables.html">Variables + Game Initialization</a></li>
				<li><a href="../gamedev/loops.html">Loops + Scene Setup</a></li>
				<li><a href="../gamedev/controlFlow.html">Control Flow + State Changes</a></li>
				<li><a href="../gamedev/functions.html">Functions + Game Events</a></li>
				<li><a href="../gamedev/advancedTopics.html">Advanced Topics</a></li>
			</ul>
		</li>
		<li>
			<a href="#">Further Resources</a>
		</li>
		<li>
			<a href="#">About</a>
		</li>
	</ul>
</nav>
<!-- /#sidebar-wrapper -->

			<div id="page-content-wrapper">
				<button type="button" class="hamburger is-closed animated fadeInLeft" data-toggle="offcanvas">
					<span class="hamb-top"></span>
					<span class="hamb-middle"></span>
					<span class="hamb-bottom"></span>
				</button>
				
<div class="container">
	<div class="row">
		<div class="col-lg-12">
			<h1 class="page-header">Functions + Game Events</h1>
			<p class='lead'>Functions are another aspect of all programming languages. They are basically sets of actions or statements that can be run repeatedly by <b>calling</b> the function. Like mathematical functions, these can take <b>parameters</b> as input and can return values as output.<br><br></p>
			<pre>function myFunction(parameter1, parameter2) {
	// run this code using parameter1 and parameter2
	return someValue				
}</pre>
			<p class='lead'>As they pertain to our game and game development in general, functions make the magic happen. Nearly all the code we have written so far was placed within the <span class='codeText'>create</span> and <span class='codeText'>update</span> functions. Though you, the developer, defined these functions, the game engine calls them (<span class='codeText'>create</span> when loading the game and <span class='codeText'>update</span> every frame). Functions are also used in games to respond to certain <b>events</b>. In our game, events include built-in ones like mouse movement and clicking, as well as ones you will define, such as the ball hitting the paddle, the bricks, or going off the bottom of the screen. To start off, we will make the game respond to mouse click by releasing the ball.<br><br>
			While some events are <b>listened</b> for during frame-by-frame updates, others can be listened for by creating <b>event listeners</b> at the start of the game (in the <span class='codeText'>create</span> function). Event listeners are ways of linking functions to events so that when something specific occurs, a proper response can be triggered. The following line creates an event listener for a mouse click:</p>
			<pre>game.input.onDown.add(releaseBall, this);</pre>
			<p class='lead'>If you added this line to your <span class='codeText'>create</span> function now, you would get an error. We have specified <span class='codeText'>releaseBall</span> as the function to be called when the mouse is clicked, but we have not defined what <span class='codeText'>releaseBall</span> is or does. To do so, we will add the following code to define it at the very bottom of your code, outside of all other functions.</p>
			<pre>function releaseBall() {

}</pre>
			<p class='lead'>Now, this function should release the ball (basically shooting it by changing its velocity) from the paddle when the mouse is clicked. However, it shouldn't release the ball if the ball is already released. Here, we will have to use control flow.</p>
			<pre>function releaseBall () {
    if (ballOnPaddle)
    {
        ballOnPaddle = false;
        ball.body.velocity.y = -300;
        ball.body.velocity.x = -75;
        introText.visible = false;
    }
}</pre>
			<p class='lead'>As in the previous lesson, we determine our actions based on whether or not the ball is on the paddle. If it is, we change its velocity and, importantly, make sure that we know the ball is no longer on the paddle by changing the value of that variable to <span class='codeText'>false</span>. Finally, we make the "click to start" text disappear because the game is started once the user clicks.</p>
		</div>
	</div>

<!-- EXERCISE -->
	<div class="row" id = "exercise1">
		<div id="editorContainer1" class = 'col-lg-12' style = "background-color:#ecf0f1; padding-top:10px; padding-bottom:10px;">
			<p style='color:#7f8c8d;'>Using the code described above in the <b>create</b> function block below, make the ball be released from the paddle when the mouse is clicked. Add in the function that releases the ball. Remember to add your code in the proper locations.<br></p>
			<p style='color:#7f8c8d;'>If your code works properly, the ball should release and the intro text should disappear when the mouse is clicked.</p>
			<div id="editor1" class='editor col-lg-12'>	var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

	var ball;
	var paddle;
	var bricks;

	var ballOnPaddle = true;
	var lives = 3;
	var score = 0;

	function preload(){

	}

	function create(){
		// add the initializing code below
		game.physics.startSystem(Phaser.Physics.ARCADE);
		game.physics.arcade.checkCollision.down = false;

		var graphics = game.add.graphics(0, 0);
		graphics.beginFill(0x68b0fd, 1);
		graphics.drawCircle(400, 550, 20);
		ball = game.add.sprite(game.world.centerX, 520, graphics.generateTexture());
		graphics.destroy();

		graphics = game.add.graphics(0, 0);
		graphics.beginFill(0xFFFFFF, 1);
		graphics.drawRect(350, 560, 100, 20);
		paddle = game.add.sprite(game.world.centerX,ball.y+20, graphics.generateTexture());
		graphics.destroy();

		//create ball body
		ball.anchor.set(0.5);
		ball.checkWorldBounds = true;
		game.physics.enable(ball, Phaser.Physics.ARCADE);
		ball.body.collideWorldBounds = true;
		ball.body.bounce.set(1);

		//create paddle
		paddle.anchor.setTo(0.5,0.5);
		game.physics.enable(paddle, Phaser.Physics.ARCADE);
		paddle.body.collideWorldBounds = true;
		paddle.body.bounce.set(1);
		paddle.body.immovable = true;
		paddle.body.allowGravity = false;
		paddle.body.enable = true;

		bricks = game.add.group();
		bricks.enableBody = true;
		bricks.physicsBodyType = Phaser.Physics.ARCADE;
		var colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f0f0];
		for (var y = 0; y < 4; y++)
		{
			graphics = game.add.graphics(0, 0);
			graphics.beginFill(colors[y], 1);
			graphics.drawRect(350, 560, 40, 20);
		    for (var x = 0; x < 13; x++)
		    {
		        var brick = bricks.create(104 + (x * 46), 100 + (y * 52), graphics.generateTexture());
		        brick.body.bounce.set(1);
		        brick.body.immovable = true;
		    }
		    graphics.destroy();
		}

		scoreText = game.add.text(32, 550, 'score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
		livesText = game.add.text(680, 550, 'lives: 3', { font: "20px Arial", fill: "#ffffff", align: "left" });
		introText = game.add.text(game.world.centerX, 400, '- click to start -', { font: "40px Arial", fill: "#ffffff", align: "center" });
		introText.anchor.setTo(0.5, 0.5);
	}

	function update(){
		paddle.x = game.input.x;
		if (paddle.x < 50)
		{
		    paddle.x = 50;
		}
		else if (paddle.x > game.width - 50)
		{
		    paddle.x = game.width - 50;
		}
		
		if (ballOnPaddle)
	    {
	        ball.body.x = paddle.x;
	    }
	}
	// print out the value of your variables, including game, below, and check them in the console
</div>
			<p hidden id='defaultCode1'>	var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

	var ball;
	var paddle;
	var bricks;

	var ballOnPaddle = true;
	var lives = 3;
	var score = 0;

	function preload(){

	}

	function create(){
		// add the initializing code below
		game.physics.startSystem(Phaser.Physics.ARCADE);
		game.physics.arcade.checkCollision.down = false;

		var graphics = game.add.graphics(0, 0);
		graphics.beginFill(0x68b0fd, 1);
		graphics.drawCircle(400, 550, 20);
		ball = game.add.sprite(game.world.centerX, 520, graphics.generateTexture());
		graphics.destroy();

		graphics = game.add.graphics(0, 0);
		graphics.beginFill(0xFFFFFF, 1);
		graphics.drawRect(350, 560, 100, 20);
		paddle = game.add.sprite(game.world.centerX,ball.y+20, graphics.generateTexture());
		graphics.destroy();

		//create ball body
		ball.anchor.set(0.5);
		ball.checkWorldBounds = true;
		game.physics.enable(ball, Phaser.Physics.ARCADE);
		ball.body.collideWorldBounds = true;
		ball.body.bounce.set(1);

		//create paddle
		paddle.anchor.setTo(0.5,0.5);
		game.physics.enable(paddle, Phaser.Physics.ARCADE);
		paddle.body.collideWorldBounds = true;
		paddle.body.bounce.set(1);
		paddle.body.immovable = true;
		paddle.body.allowGravity = false;
		paddle.body.enable = true;

		bricks = game.add.group();
		bricks.enableBody = true;
		bricks.physicsBodyType = Phaser.Physics.ARCADE;
		var colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f0f0];
		for (var y = 0; y < 4; y++)
		{
			graphics = game.add.graphics(0, 0);
			graphics.beginFill(colors[y], 1);
			graphics.drawRect(350, 560, 40, 20);
		    for (var x = 0; x < 13; x++)
		    {
		        var brick = bricks.create(104 + (x * 46), 100 + (y * 52), graphics.generateTexture());
		        brick.body.bounce.set(1);
		        brick.body.immovable = true;
		    }
		    graphics.destroy();
		}

		scoreText = game.add.text(32, 550, 'score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
		livesText = game.add.text(680, 550, 'lives: 3', { font: "20px Arial", fill: "#ffffff", align: "left" });
		introText = game.add.text(game.world.centerX, 400, '- click to start -', { font: "40px Arial", fill: "#ffffff", align: "center" });
		introText.anchor.setTo(0.5, 0.5);
	}

	function update(){
		paddle.x = game.input.x;
		if (paddle.x < 50)
		{
		    paddle.x = 50;
		}
		else if (paddle.x > game.width - 50)
		{
		    paddle.x = game.width - 50;
		}
		
		if (ballOnPaddle)
	    {
	        ball.body.x = paddle.x;
	    }
	}
	// print out the value of your variables, including game, below, and check them in the console
</p>
			<div id="frame1" class='col-lg-12'>
				<iframe id="iframe1"></iframe>
			</div>
			<div class = "btn-group" role="group" aria-label="Editor Buttons">
				<button id="run1" class="btn btn-med btn-warning">Update <i class="fa fa-play fa-fw" aria-hidden="true"></i></button>
				<button id="reset1" class="btn btn-med btn-default">Reset <i class="fa fa-repeat fa-fw" aria-hidden="true"></i></button>
			</div>
			<p id = "editorContent1" style = "visibility:hidden;width:0px;height:0px;"></p>
		</div>
	</div>
	<!-- END EXERCISE -->

	<div class="row">
		<div class="col-lg-12">
			<p class='lead'>You probably noticed that after you clicked, the ball just passed through the bricks and the paddle and then disappeared of the bottom of the screen. To fix this, we need to make the ball collide and bounce off of the bricks and the paddle and decrease the number of lives when the the ball goes off the screen. <br><br>
			First, we must add an <span class='codeText'>else</span> to the control flow statement in <b>update</b> checking whether the ball is on the paddle. When the ball isn't on the paddle, we want it to collide with the balls and/or the paddle and trigger a corresponding action. The control flow statement becomes:</p>
			<pre>if (ballOnPaddle)
{
    ball.body.x = paddle.x;
}
else
{
    game.physics.arcade.collide(ball, paddle, ballHitPaddle, null, this);
    game.physics.arcade.collide(ball, bricks, ballHitBrick, null, this);
}</pre>
			<p class='lead'>This code would produce an error if you added it and ran it now because we have not defined the functions <span class='codeText'>ballHitPaddle</span> and <span class='codeText'>ballHitBrick</span>. Let's do that now.<br><br>
			The following is the basic structure for these two functions:</p>
			<pre>function ballHitBrick (_ball, _brick) {

}

function ballHitPaddle (_ball, _paddle) {
	
}</pre>
			<p class='lead'> These functions will be placed at the bottom of your code, outside of any other functions. Notice that each accepts two parameters meant to be the ball and the object it hits (the _ is required before each name to distinguish the parameters from the variables we defined earlier). These parameters are necessary for the function to work properly as a response to an event. Phaser will call these functions and pass in the parameters of the objects interacting so that the function can use them.<br><br>
			For <span class='codeText'>ballHitBrick</span>, one action that needs to be taken is to destroy the brick. This can be done with the following line:</p>
			<pre>_brick.kill();</pre>
			<p class='lead'>When the ball hits a brick, the score should be increased. This is as simple as incrementing the variable:</p>
			<pre>score += 10;</pre>
			<p class='lead'>Remember this syntax is equivalent to <span class='codeText'>score = score + 10;</span>. After the score variable is updated, we still need to update the text to reflect that score:</p>
			<pre>scoreText.text = 'score: ' + score;</pre>
			<p class='lead'>We're not done yet. What if the ball hits the last brick on the screen? We then need to start the next level by adding a bonus to the score, showing the intro text again, putting the ball back on the paddle, and resetting all the bricks. First, we must add an <span class='codeText'>if</span> statement to check whether the current brick being hit is the last one. Since we already destroyed it, we can simply check if there are zero bricks left by checking the count of the number of objects left in the <span class='codeText'>bricks</span> group:</p>
			<pre>if (bricks.countLiving() == 0){

}</pre>
			<p class='lead'>Next, within the <span class='codeText'>{...}</span>, increment the score by some bonus amount, like 1000. Update the score text as was done above and reset the intro text:</p>
			<pre>score += 1000;
scoreText.text = 'score: ' + score;
introText.text = '- Next Level -';</pre>
			<p class='lead'>To put the ball back on the paddle, first update the variable we use to check whether the ball is currently on the paddle. Then, set its velocity to 0 (make it stop moving), and place it in its original position right on the paddle:</p>
			<pre>ballOnPaddle = true;
ball.body.velocity.set(0);
ball.x = paddle.x;
ball.y = paddle.y - 20;</pre>
			<p class='lead'>Finally, to reset all the bricks, use the following special function for Phaser object groups:</p>
			<pre>bricks.callAll('revive');</pre>
			<p class='lead'>The completed <span class='codeText'>ballHitBrick</span> function should look like this:</p>
			<pre>function ballHitBrick (_ball, _brick) {
    _brick.kill();
    score += 10;
    scoreText.text = 'score: ' + score;
    if (bricks.countLiving() == 0)
    {
        score += 1000;
        scoreText.text = 'score: ' + score;
        introText.text = '- Next Level -';
        ballOnPaddle = true;
        ball.body.velocity.set(0);
        ball.x = paddle.x;
        ball.y = paddle.y - 20;
        bricks.callAll('revive');
    }
}</pre>

			<p class='lead'>The <span class='codeText'>ballHitPaddle</span> function would seem unnecessary since the ball can bounce off the paddle already. However, in this function we will write code that prevents the ball from slowing down and allows the player to change the direction of the ball depending on where it hits the paddle, giving the effect of spin. This will involve an <span class='codeText'>if-else</span> statement to determine where the ball is contacting the paddle. First, define a variable to store the difference in the ball's position and the paddle's, which will be used to determine the magnitude of the change to the ball's velocity.</p>
			<pre>function ballHitPaddle (_ball, _paddle) {
    var diff = 0;
    if (_ball.x != _paddle.x)
    {
        
    }
    else
    {

    }
}</pre>
			<p class='lead'>In the first part of the <span class='codeText'>if</span> statement, we check if the center of the ball is to the left or right of the center of the paddle (i.e. the ball is on the left or right side of the paddle). The <span class='codeText'>else</span> checks the only other possibility, that the ball is directly in the center of the paddle. While the effect isn't completely realistic, the idea is that the further to the one side of the paddle the ball hits, the sharper the bounce it will make in that direction.<br><br>
			For the left side of the paddle, the velocity should become negative (going towards the left), so we can calculate the difference between ball and paddle positions (which will be positive) and multiply that by a negative number. Similarly, for the right side of the paddle, the velocity should become positive (going towards the right), so we can calculate the position difference (which will be negative) and multiply that by a negative number. Since we are making the same change to the velocity, we don't need to make calculations for each side of the paddle separately.</p>
			<pre>if (_ball.x != _paddle.x)
{
    diff = _paddle.x - _ball.x;
    _ball.body.velocity.x = (-10 * diff);
}
else
{
    _ball.body.velocity.x = 2 + Math.random() * 8;
}</pre>
			<p class='lead'>In this code, <span class='codeText'>diff</span> stores the difference in horizontal positions of the two objects. Then, the velocity of the ball becomes this difference times -10. In the <span class='codeText'>else</span> part, the velocity is set to a random positive number to ensure that the ball doesn't get stuck bouncing straight up and down.</p>
		</div>
	</div>

	<!-- EXERCISE -->
	<div class="row" id = "exercise2">
		<div id="editorContainer2" class = 'col-lg-12' style = "background-color:#ecf0f1; padding-top:10px; padding-bottom:10px;">
			<p style='color:#7f8c8d;'>Using the code described above in the <b>update</b> function block below, make the ball collide with the bricks and the paddle. Add in the functions that respond to these events. Remember to add your code in the proper locations.<br></p>
			<p style='color:#7f8c8d;'>If your code works properly, the ball should hit and destroy the bricks while increasing the score, reset the bricks when the level is complete, and bounce off the paddle in a direction depending on the position of the ball on the paddle.</p>
			<div id="editor2" class='editor col-lg-12'>	var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

	var ball;
	var paddle;
	var bricks;

	var ballOnPaddle = true;
	var lives = 3;
	var score = 0;

	function preload(){

	}

	function create(){
		// add the initializing code below
		game.physics.startSystem(Phaser.Physics.ARCADE);
		game.physics.arcade.checkCollision.down = false;

		var graphics = game.add.graphics(0, 0);
		graphics.beginFill(0x68b0fd, 1);
		graphics.drawCircle(400, 550, 20);
		ball = game.add.sprite(game.world.centerX, 520, graphics.generateTexture());
		graphics.destroy();

		graphics = game.add.graphics(0, 0);
		graphics.beginFill(0xFFFFFF, 1);
		graphics.drawRect(350, 560, 100, 20);
		paddle = game.add.sprite(game.world.centerX,ball.y+20, graphics.generateTexture());
		graphics.destroy();

		//create ball body
		ball.anchor.set(0.5);
		ball.checkWorldBounds = true;
		game.physics.enable(ball, Phaser.Physics.ARCADE);
		ball.body.collideWorldBounds = true;
		ball.body.bounce.set(1);

		//create paddle
		paddle.anchor.setTo(0.5,0.5);
		game.physics.enable(paddle, Phaser.Physics.ARCADE);
		paddle.body.collideWorldBounds = true;
		paddle.body.bounce.set(1);
		paddle.body.immovable = true;
		paddle.body.allowGravity = false;
		paddle.body.enable = true;

		bricks = game.add.group();
		bricks.enableBody = true;
		bricks.physicsBodyType = Phaser.Physics.ARCADE;
		var colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f0f0];
		for (var y = 0; y < 4; y++)
		{
			graphics = game.add.graphics(0, 0);
			graphics.beginFill(colors[y], 1);
			graphics.drawRect(350, 560, 40, 20);
		    for (var x = 0; x < 13; x++)
		    {
		        var brick = bricks.create(104 + (x * 46), 100 + (y * 52), graphics.generateTexture());
		        brick.body.bounce.set(1);
		        brick.body.immovable = true;
		    }
		    graphics.destroy();
		}

		scoreText = game.add.text(32, 550, 'score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
		livesText = game.add.text(680, 550, 'lives: 3', { font: "20px Arial", fill: "#ffffff", align: "left" });
		introText = game.add.text(game.world.centerX, 400, '- click to start -', { font: "40px Arial", fill: "#ffffff", align: "center" });
		introText.anchor.setTo(0.5, 0.5);

		game.input.onDown.add(releaseBall, this);
	}

	function update(){
		paddle.x = game.input.x;
		if (paddle.x < 50)
		{
		    paddle.x = 50;
		}
		else if (paddle.x > game.width - 50)
		{
		    paddle.x = game.width - 50;
		}

		if (ballOnPaddle)
	    {
	        ball.body.x = paddle.x;
	    }

	}

	function releaseBall () {
	    if (ballOnPaddle)
	    {
	        ballOnPaddle = false;
	        ball.body.velocity.y = -300;
	        ball.body.velocity.x = -75;
	        introText.visible = false;
	    }
	}
	// print out the value of your variables, including game, below, and check them in the console
</div>
			<p hidden id='defaultCode1'>		var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

	var ball;
	var paddle;
	var bricks;

	var ballOnPaddle = true;
	var lives = 3;
	var score = 0;

	function preload(){

	}

	function create(){
		// add the initializing code below
		game.physics.startSystem(Phaser.Physics.ARCADE);
		game.physics.arcade.checkCollision.down = false;

		var graphics = game.add.graphics(0, 0);
		graphics.beginFill(0x68b0fd, 1);
		graphics.drawCircle(400, 550, 20);
		ball = game.add.sprite(game.world.centerX, 520, graphics.generateTexture());
		graphics.destroy();

		graphics = game.add.graphics(0, 0);
		graphics.beginFill(0xFFFFFF, 1);
		graphics.drawRect(350, 560, 100, 20);
		paddle = game.add.sprite(game.world.centerX,ball.y+20, graphics.generateTexture());
		graphics.destroy();

		//create ball body
		ball.anchor.set(0.5);
		ball.checkWorldBounds = true;
		game.physics.enable(ball, Phaser.Physics.ARCADE);
		ball.body.collideWorldBounds = true;
		ball.body.bounce.set(1);

		//create paddle
		paddle.anchor.setTo(0.5,0.5);
		game.physics.enable(paddle, Phaser.Physics.ARCADE);
		paddle.body.collideWorldBounds = true;
		paddle.body.bounce.set(1);
		paddle.body.immovable = true;
		paddle.body.allowGravity = false;
		paddle.body.enable = true;

		bricks = game.add.group();
		bricks.enableBody = true;
		bricks.physicsBodyType = Phaser.Physics.ARCADE;
		var colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f0f0];
		for (var y = 0; y < 4; y++)
		{
			graphics = game.add.graphics(0, 0);
			graphics.beginFill(colors[y], 1);
			graphics.drawRect(350, 560, 40, 20);
		    for (var x = 0; x < 13; x++)
		    {
		        var brick = bricks.create(104 + (x * 46), 100 + (y * 52), graphics.generateTexture());
		        brick.body.bounce.set(1);
		        brick.body.immovable = true;
		    }
		    graphics.destroy();
		}

		scoreText = game.add.text(32, 550, 'score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
		livesText = game.add.text(680, 550, 'lives: 3', { font: "20px Arial", fill: "#ffffff", align: "left" });
		introText = game.add.text(game.world.centerX, 400, '- click to start -', { font: "40px Arial", fill: "#ffffff", align: "center" });
		introText.anchor.setTo(0.5, 0.5);

		game.input.onDown.add(releaseBall, this);
	}

	function update(){
		paddle.x = game.input.x;
		if (paddle.x < 50)
		{
		    paddle.x = 50;
		}
		else if (paddle.x > game.width - 50)
		{
		    paddle.x = game.width - 50;
		}

		if (ballOnPaddle)
	    {
	        ball.body.x = paddle.x;
	    }

	}

	function releaseBall () {
	    if (ballOnPaddle)
	    {
	        ballOnPaddle = false;
	        ball.body.velocity.y = -300;
	        ball.body.velocity.x = -75;
	        introText.visible = false;
	    }
	}
	// print out the value of your variables, including game, below, and check them in the console
</p>
			<div id="frame2" class='col-lg-12'>
				<iframe id="iframe2"></iframe>
			</div>
			<div class = "btn-group" role="group" aria-label="Editor Buttons">
				<button id="run2" class="btn btn-med btn-warning">Update <i class="fa fa-play fa-fw" aria-hidden="true"></i></button>
				<button id="reset2" class="btn btn-med btn-default">Reset <i class="fa fa-repeat fa-fw" aria-hidden="true"></i></button>
			</div>
			<p id = "editorContent2" style = "visibility:hidden;width:0px;height:0px;"></p>
		</div>
	</div>
	<!-- END EXERCISE -->

	<div class="row">
		<div class="col-lg-12">
			<p class='lead'>The game mostly works now, but if you played long enough, you noticed that when the ball goes out of bounds at the bottom, it doesn't reset and the game becomes unplayable. To fix this and finish the game, we must first allow the ball to trigger an event when it goes out of bounds. Like creating the event listener for mouse clicks, this is a default operation that can be done in the <span class='codeText'>create</span> function:</p>
			<pre>ball.events.onOutOfBounds.add(ballLost, this);</pre>
			<p class='lead'>To make this code work, we must add the <span class='codeText'>ballLost</span> function at the bottom of the code to respond to this event. Unlike the <span class='codeText'>ballHitBrick</span> and <span class='codeText'>ballHitPaddle</span> functions, this function doesn't need to accept parameters:</p>
			<pre>function ballLost() {

}</pre>
			<p class='lead'>First, we must lower the number of lives remaining by decreasing the variable by 1 and updating the text:</p>
			<pre>lives--;
livesText.text = 'lives: ' + lives;</pre>
			<p class='lead'>Next, we have to check if this life was the last remaining, meaning the game is now over. If it is, then the ball should be stopped and the intro text should be updated to say "Game Over!". If it is not the last life, then ball should be reset to the paddle (and the variable reflecting that status set to true).</p>
			<pre>if (lives === 0)
{
    ball.body.velocity.setTo(0, 0);
    introText.text = 'Game Over!';
    introText.visible = true;
}
else
{
    ballOnPaddle = true;
    ball.reset(paddle.body.x, paddle.y - 20);
}</pre>
			<p class='lead'>The completed <span class='codeText'>ballLost</span> function is below.</p>
			<pre>function ballLost () {
    lives--;
    livesText.text = 'lives: ' + lives;
    if (lives === 0)
    {
        ball.body.velocity.setTo(0, 0);
	    introText.text = 'Game Over!';
	    introText.visible = true;
    }
    else
    {
        ballOnPaddle = true;
        ball.reset(paddle.body.x, paddle.y - 20);
    }
}</pre>
			
	<!-- EXERCISE -->
	<div class="row" id = "exercise3">
		<div id="editorContainer3" class = 'col-lg-12' style = "background-color:#ecf0f1; padding-top:10px; padding-bottom:10px;">
			<p style='color:#7f8c8d;'>Using the code described above in the <b>update</b> function block below, make the ball trigger an event when it goes out of bounds. Add in the function that responds to this event. Remember to add your code in the proper locations.<br></p>
			<p style='color:#7f8c8d;'>If your code works properly, the ball should reset after going out of bounds, and the number of lives should decrease. If the number of lives becomes 0, the game should end.</p>
			<div id="editor3" class='editor col-lg-12'>var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

var ball;
var paddle;
var bricks;

var ballOnPaddle = true;
var lives = 3;
var score = 0;

function preload(){

}

function create(){
	// add the initializing code below
	game.physics.startSystem(Phaser.Physics.ARCADE);
	game.physics.arcade.checkCollision.down = false;

	var graphics = game.add.graphics(0, 0);
	graphics.beginFill(0x68b0fd, 1);
	graphics.drawCircle(400, 550, 20);
	ball = game.add.sprite(game.world.centerX, 520, graphics.generateTexture());
	graphics.destroy();

	graphics = game.add.graphics(0, 0);
	graphics.beginFill(0xFFFFFF, 1);
	graphics.drawRect(350, 560, 100, 20);
	paddle = game.add.sprite(game.world.centerX,ball.y+20, graphics.generateTexture());
	graphics.destroy();

	//create ball body
	ball.anchor.set(0.5);
	ball.checkWorldBounds = true;
	game.physics.enable(ball, Phaser.Physics.ARCADE);
	ball.body.collideWorldBounds = true;
	ball.body.bounce.set(1);

	//create paddle
	paddle.anchor.setTo(0.5,0.5);
	game.physics.enable(paddle, Phaser.Physics.ARCADE);
	paddle.body.collideWorldBounds = true;
	paddle.body.bounce.set(1);
	paddle.body.immovable = true;
	paddle.body.allowGravity = false;
	paddle.body.enable = true;

	bricks = game.add.group();
	bricks.enableBody = true;
	bricks.physicsBodyType = Phaser.Physics.ARCADE;
	var colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f0f0];
	for (var y = 0; y < 4; y++)
	{
		graphics = game.add.graphics(0, 0);
		graphics.beginFill(colors[y], 1);
		graphics.drawRect(350, 560, 40, 20);
	    for (var x = 0; x < 13; x++)
	    {
	        var brick = bricks.create(104 + (x * 46), 100 + (y * 52), graphics.generateTexture());
	        brick.body.bounce.set(1);
	        brick.body.immovable = true;
	    }
	    graphics.destroy();
	}

	scoreText = game.add.text(32, 550, 'score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
	livesText = game.add.text(680, 550, 'lives: 3', { font: "20px Arial", fill: "#ffffff", align: "left" });
	introText = game.add.text(game.world.centerX, 400, '- click to start -', { font: "40px Arial", fill: "#ffffff", align: "center" });
	introText.anchor.setTo(0.5, 0.5);

	game.input.onDown.add(releaseBall, this);
}

function update(){
	paddle.x = game.input.x;
	if (paddle.x < 50)
	{
	    paddle.x = 50;
	}
	else if (paddle.x > game.width - 50)
	{
	    paddle.x = game.width - 50;
	}

	if (ballOnPaddle)
    {
        ball.body.x = paddle.x;
    }
    else
    {
        game.physics.arcade.collide(ball, paddle, ballHitPaddle, null, this);
        game.physics.arcade.collide(ball, bricks, ballHitBrick, null, this);
    }

}

function releaseBall () {
    if (ballOnPaddle)
    {
        ballOnPaddle = false;
        ball.body.velocity.y = -300;
        ball.body.velocity.x = -75;
        introText.visible = false;
    }
}

function ballHitBrick (_ball, _brick) {
    _brick.kill();
    score += 10;
    scoreText.text = 'score: ' + score;
    if (bricks.countLiving() == 0)
    {
        score += 1000;
        scoreText.text = 'score: ' + score;
        introText.text = '- Next Level -';
        ballOnPaddle = true;
        ball.body.velocity.set(0);
        ball.x = paddle.x;
        ball.y = paddle.y - 20;
        bricks.callAll('revive');
    }
}

function ballHitPaddle (_ball, _paddle) {
    var diff = 0;
    if (_ball.x != _paddle.x)
    {
        diff = _paddle.x - _ball.x;
        _ball.body.velocity.x = (-10 * diff);
    }
    else
    {
        _ball.body.velocity.x = 2 + Math.random() * 8;
    }

}
// print out the value of your variables, including game, below, and check them in the console
</div>
			<p hidden id='defaultCode1'>var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

var ball;
var paddle;
var bricks;

var ballOnPaddle = true;
var lives = 3;
var score = 0;

function preload(){

}

function create(){
	// add the initializing code below
	game.physics.startSystem(Phaser.Physics.ARCADE);
	game.physics.arcade.checkCollision.down = false;

	var graphics = game.add.graphics(0, 0);
	graphics.beginFill(0x68b0fd, 1);
	graphics.drawCircle(400, 550, 20);
	ball = game.add.sprite(game.world.centerX, 520, graphics.generateTexture());
	graphics.destroy();

	graphics = game.add.graphics(0, 0);
	graphics.beginFill(0xFFFFFF, 1);
	graphics.drawRect(350, 560, 100, 20);
	paddle = game.add.sprite(game.world.centerX,ball.y+20, graphics.generateTexture());
	graphics.destroy();

	//create ball body
	ball.anchor.set(0.5);
	ball.checkWorldBounds = true;
	game.physics.enable(ball, Phaser.Physics.ARCADE);
	ball.body.collideWorldBounds = true;
	ball.body.bounce.set(1);

	//create paddle
	paddle.anchor.setTo(0.5,0.5);
	game.physics.enable(paddle, Phaser.Physics.ARCADE);
	paddle.body.collideWorldBounds = true;
	paddle.body.bounce.set(1);
	paddle.body.immovable = true;
	paddle.body.allowGravity = false;
	paddle.body.enable = true;

	bricks = game.add.group();
	bricks.enableBody = true;
	bricks.physicsBodyType = Phaser.Physics.ARCADE;
	var colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f0f0];
	for (var y = 0; y < 4; y++)
	{
		graphics = game.add.graphics(0, 0);
		graphics.beginFill(colors[y], 1);
		graphics.drawRect(350, 560, 40, 20);
	    for (var x = 0; x < 13; x++)
	    {
	        var brick = bricks.create(104 + (x * 46), 100 + (y * 52), graphics.generateTexture());
	        brick.body.bounce.set(1);
	        brick.body.immovable = true;
	    }
	    graphics.destroy();
	}

	scoreText = game.add.text(32, 550, 'score: 0', { font: "20px Arial", fill: "#ffffff", align: "left" });
	livesText = game.add.text(680, 550, 'lives: 3', { font: "20px Arial", fill: "#ffffff", align: "left" });
	introText = game.add.text(game.world.centerX, 400, '- click to start -', { font: "40px Arial", fill: "#ffffff", align: "center" });
	introText.anchor.setTo(0.5, 0.5);

	game.input.onDown.add(releaseBall, this);
}

function update(){
	paddle.x = game.input.x;
	if (paddle.x < 50)
	{
	    paddle.x = 50;
	}
	else if (paddle.x > game.width - 50)
	{
	    paddle.x = game.width - 50;
	}

	if (ballOnPaddle)
    {
        ball.body.x = paddle.x;
    }
    else
    {
        game.physics.arcade.collide(ball, paddle, ballHitPaddle, null, this);
        game.physics.arcade.collide(ball, bricks, ballHitBrick, null, this);
    }

}

function releaseBall () {
    if (ballOnPaddle)
    {
        ballOnPaddle = false;
        ball.body.velocity.y = -300;
        ball.body.velocity.x = -75;
        introText.visible = false;
    }
}

function ballHitBrick (_ball, _brick) {
    _brick.kill();
    score += 10;
    scoreText.text = 'score: ' + score;
    if (bricks.countLiving() == 0)
    {
        score += 1000;
        scoreText.text = 'score: ' + score;
        introText.text = '- Next Level -';
        ballOnPaddle = true;
        ball.body.velocity.set(0);
        ball.x = paddle.x;
        ball.y = paddle.y - 20;
        bricks.callAll('revive');
    }
}

function ballHitPaddle (_ball, _paddle) {
    var diff = 0;
    if (_ball.x != _paddle.x)
    {
        diff = _paddle.x - _ball.x;
        _ball.body.velocity.x = (-10 * diff);
    }
    else
    {
        _ball.body.velocity.x = 2 + Math.random() * 8;
    }

}
// print out the value of your variables, including game, below, and check them in the console
</p>
			<div id="frame3" class='col-lg-12'>
				<iframe id="iframe3"></iframe>
			</div>
			<div class = "btn-group" role="group" aria-label="Editor Buttons">
				<button id="run3" class="btn btn-med btn-warning">Update <i class="fa fa-play fa-fw" aria-hidden="true"></i></button>
				<button id="reset3" class="btn btn-med btn-default">Reset <i class="fa fa-repeat fa-fw" aria-hidden="true"></i></button>
			</div>
			<p id = "editorContent3" style = "visibility:hidden;width:0px;height:0px;"></p>
		</div>
	</div>
	<!-- END EXERCISE -->
	<div class="row">
		<div class="col-lg-12">
			<p class='lead'><br>That's it. The game should now be fully functioning. To see the completed code, click <a href='../js/breakout.js' target="_blank">here</a>.</p>
		</div>
	</div>

	<div class = "col-lg-4 col-lg-offset-4" style = "margin-top:40px;">
		<a href = "advancedTopics.html" class="btn btn-lg btn-block btn-warning" style="color:white;text-decoration:none;"><h4>Next<i class="fa fa-caret-right fa-fw" aria-hidden="true"></i></h4></a>
	</div>

</div>

			</div>
			<!-- /#page-content-wrapper -->

			
		</div>
		<!-- /#wrapper -->

		

		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="../node_modules/bootstrap/dist/js/bootstrap.min.js"></script>

		
<script type="text/javascript">
	$(document).ready(function(){
		activateGameEditor(1);
		activateGameEditor(2);
		activateGameEditor(3);
	});
</script>

		<script type='text/javascript' src='../js/interact.js'></script>
		<script type="text/javascript">
			$(document).ready(function () {
				var trigger = $('.hamburger'),
				overlay = $('.overlay'),
				isClosed = false;

				trigger.click(function () {
					hamburger_cross();      
				});

				function hamburger_cross() {

					if (isClosed == true) {          
						overlay.hide();
						trigger.removeClass('is-open');
						trigger.addClass('is-closed');
						isClosed = false;
					} else {   
						overlay.show();
						trigger.removeClass('is-closed');
						trigger.addClass('is-open');
						isClosed = true;
					}
				}

				$('[data-toggle="offcanvas"]').click(function () {
					$('#wrapper').toggleClass('toggled');
				});
			});
			$('.navbar .dropdown').click(function() {
			    $(this).find('.dropdown-menu').first().stop(true, true).slideToggle();
			});
		</script>

		<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
			<defs>
				<filter id="blur">
					<feGaussianBlur stdDeviation="5" />
				</filter>
			</defs>
		</svg>
	</body>
</html>